import { S as SvelteComponentDev, i as init, s as safe_not_equal, e as element, t as text, c as claim_element, b as children, d as claim_text, f as detach, g as attr, E as set_style, h as add_location, j as insert, k as append, w as set_data, a as space, D as listen, n as noop, I as destroy_each, J as validate_store, K as subscribe, x as empty, r as transition_out, C as check_outros, q as transition_in, F as create_out_transition, B as group_outros, G as add_render_callback, H as create_in_transition, m as mount_component, u as destroy_component } from './chunk.1f1ec905.js';
import { w as writable } from './chunk.1a249daf.js';
import { f as fade } from './chunk.62ee5756.js';

const actors = writable([]);
const map = writable(new Map());

/* src/components/Map.svelte generated by Svelte v3.6.7 */

const file = "src/components/Map.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.actor = list[i];
	return child_ctx;
}

// (189:4) {#each actor_list as actor}
function create_each_block(ctx) {
	var p, t0, t1_value = ctx.actor, t1, p_id_value;

	return {
		c: function create() {
			p = element("p");
			t0 = text("ðŸ¤–");
			t1 = text(t1_value);
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true, id: true, style: true }, false);
			var p_nodes = children(p);

			t0 = claim_text(p_nodes, "ðŸ¤–");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(p, "class", "actor svelte-14n8rsr");
			attr(p, "id", p_id_value = ctx.actor);
			set_style(p, "left", "" + ctx.$map.get(ctx.actor)['x'] + "%");
			set_style(p, "bottom", "" + ctx.$map.get(ctx.actor)['y'] + "%");
			add_location(p, file, 189, 4, 5296);
		},

		m: function mount(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.actor_list) && t1_value !== (t1_value = ctx.actor)) {
				set_data(t1, t1_value);
			}

			if ((changed.actor_list) && p_id_value !== (p_id_value = ctx.actor)) {
				attr(p, "id", p_id_value);
			}

			if (changed.$map || changed.actor_list) {
				set_style(p, "left", "" + ctx.$map.get(ctx.actor)['x'] + "%");
				set_style(p, "bottom", "" + ctx.$map.get(ctx.actor)['y'] + "%");
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(p);
			}
		}
	};
}

function create_fragment(ctx) {
	var div, t0, button, t1, dispose;

	var each_value = ctx.actor_list;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c: function create() {
			div = element("div");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			button = element("button");
			t1 = text("Click me to start data stream");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true }, false);
			var div_nodes = children(div);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			t0 = claim_text(nodes, "\n\n");

			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t1 = claim_text(button_nodes, "Click me to start data stream");
			button_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div, "id", "map");
			attr(div, "class", "svelte-14n8rsr");
			add_location(div, file, 187, 0, 5245);
			attr(button, "class", "svelte-14n8rsr");
			add_location(button, file, 194, 0, 5431);
			dispose = listen(button, "click", ctx.fetch_map);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			insert(target, t0, anchor);
			insert(target, button, anchor);
			append(button, t1);
		},

		p: function update(changed, ctx) {
			if (changed.actor_list || changed.$map) {
				each_value = ctx.actor_list;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach(t0);
				detach(button);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $actors, $map;

	validate_store(actors, 'actors');
	subscribe($$self, actors, $$value => { $actors = $$value; $$invalidate('$actors', $actors); });
	validate_store(map, 'map');
	subscribe($$self, map, $$value => { $map = $$value; $$invalidate('$map', $map); });

	let x, y;
    let data = [];

    let prev_messages = '';
    let new_messages = '';

    let current_host;


    // Prevennts an error when Svelte does SSR.
    {
        let xhr = new XMLHttpRequest();
        current_host = window.location.host.toString();
        console.log('current host is: ', current_host);
    }

    //need to create an array of actors because Svelte can't iterate over Map objects
    function gen_actor_list() {
        // let arr = [];
        $actors = []; actors.set($actors);
        for (let item of $map.keys()) {
            $actors.push(item);
        }
        return $actors
    }

    function process_map_data(data_point_array) {
        //handle multiple data points sent in a single update
        if (data_point_array[data_point_array.length - 1].length > 1) {
            data_point_array = data.slice(-1);
                //console.log("data_point_array is: ")
                //console.log(data_point_array)
            data_point_array.forEach(function(item, index) {
                item.forEach(function(sub_item, index) {
                    //console.log(sub_item, index);
                    process_data_point(sub_item);
                });
            });

            //console.log('data_point_array - if')
            //console.log(data_point_array)
        } else {
            data_point_array = data.slice(-1);
            process_data_point(data_point_array);
                //console.log('data_point_array - else')
                //console.log(data_point_array)
        }

        function process_data_point(data_point) {
            // let data_point = data_point_array[data_point_array.length - 1]
            //console.log('data_point: ')
            //console.log(data_point)
            try {
                data_point = JSON.parse(data_point);
            } catch (error) {
                //console.error(error)
                return
            }

            //console.log("parsed data_point")
            //console.log(data_point)

            let actor = data_point.actor;
            if (data_point.x <= 0) {
                x = 0;
            } else if (data_point.x >= 90) {
                x = 90;
            } else {
                x = data_point.x;
            }

            if (data_point.y <= 5) {
                y = 5;
            } else if (data_point.y >= 95) {
                y = 95;
            } else {
                y = data_point.y;
            }
            //console.log(x)
            //console.log(y)
            //console.log(actor)

            $map.set(actor, {
                'x': x,
                'y': y
            });
        }
    }



    async function fetch_map(event) {
        let xhr = new XMLHttpRequest();
        xhr.responseType = 'text';
        let url = 'https://' + current_host + '/kafka-client-api/read?topic=actors';
        console.log("url is: ", url);
        xhr.open("GET", url);
        xhr.timeout = Infinity;
        xhr.onloadstart = function() {
            //console.log("Download underway");
        };
        xhr.onprogress = function(event) {
            let response = xhr.response;
                // trim the last message's trailing '::::' and split on '::::'
            new_messages = response.slice(prev_messages.length, response.length - 4).split('::::');
            prev_messages = response;
                //console.log('new_msgs')
                //console.log(new_messages)
            data.push(new_messages);
                // set data = data to trigger view update, keeping only last 100 messages in order to prevent browser from getting bogged down.
            if (data.length >= 100) {
                data = data.splice(-100, data.length);
            }
            // set x and y coords
            //console.log('data.slice(-1)')
            //console.log(data.slice(-1))

            process_map_data(data.slice(-1));
                // let data_point_array = data.slice(-1)
                //call gen_actor_list to update list of actors
                //TODO: confirm if this step is necessary, given it's defined as reactive above-- $: actor_list = gen_actor_list()
            $$invalidate('actor_list', actor_list = gen_actor_list());
        };
        xhr.send();
        xhr.onload = function() {
            //TODO: reconnect on completion
            //console.log(xhr.response)
        };
    }

	let actor_list;

	$$invalidate('actor_list', actor_list = gen_actor_list());

	return { fetch_map, actor_list, $map };
}

class Map$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

/* src/components/ActorStatus.svelte generated by Svelte v3.6.7 */

const file$1 = "src/components/ActorStatus.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.actor = list[i];
	return child_ctx;
}

// (91:8) {:else}
function create_else_block(ctx) {
	var each_1_anchor;

	var each_value = ctx.$actors;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c: function create() {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.$map || changed.$actors) {
				each_value = ctx.$actors;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

// (89:8) {#if $actors.length == 0}
function create_if_block(ctx) {
	var p, t;

	return {
		c: function create() {
			p = element("p");
			t = text("Waiting for data...");
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", {}, false);
			var p_nodes = children(p);

			t = claim_text(p_nodes, "Waiting for data...");
			p_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(p, file$1, 89, 8, 2069);
		},

		m: function mount(target, anchor) {
			insert(target, p, anchor);
			append(p, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(p);
			}
		}
	};
}

// (91:16) {#each $actors as actor}
function create_each_block$1(ctx) {
	var li, span0, t0_value = ctx.actor, t0, t1, hr, t2, div, span1, t3, t4_value = ctx.$map.get(ctx.actor)['x'], t4, t5, t6_value = ctx.$map.get(ctx.actor)['y'], t6, t7, span3, t8, span2, t9, t10;

	return {
		c: function create() {
			li = element("li");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = space();
			hr = element("hr");
			t2 = space();
			div = element("div");
			span1 = element("span");
			t3 = text("x: ");
			t4 = text(t4_value);
			t5 = text(", y: ");
			t6 = text(t6_value);
			t7 = space();
			span3 = element("span");
			t8 = text("Status: ");
			span2 = element("span");
			t9 = text("OK");
			t10 = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			span0 = claim_element(li_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach);
			t1 = claim_text(li_nodes, "\n            ");

			hr = claim_element(li_nodes, "HR", { class: true }, false);
			var hr_nodes = children(hr);

			hr_nodes.forEach(detach);
			t2 = claim_text(li_nodes, "\n            ");

			div = claim_element(li_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span1 = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			t3 = claim_text(span1_nodes, "x: ");
			t4 = claim_text(span1_nodes, t4_value);
			t5 = claim_text(span1_nodes, ", y: ");
			t6 = claim_text(span1_nodes, t6_value);
			span1_nodes.forEach(detach);
			t7 = claim_text(div_nodes, "\n                ");

			span3 = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span3_nodes = children(span3);

			t8 = claim_text(span3_nodes, "Status: ");

			span2 = claim_element(span3_nodes, "SPAN", { style: true }, false);
			var span2_nodes = children(span2);

			t9 = claim_text(span2_nodes, "OK");
			span2_nodes.forEach(detach);
			span3_nodes.forEach(detach);
			div_nodes.forEach(detach);
			t10 = claim_text(li_nodes, "\n        ");
			li_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(span0, "class", "actor_list__actor_name svelte-1wx09m9");
			add_location(span0, file$1, 92, 12, 2187);
			attr(hr, "class", "svelte-1wx09m9");
			add_location(hr, file$1, 95, 12, 2290);
			attr(span1, "class", "actor_list__actor_coordinates svelte-1wx09m9");
			add_location(span1, file$1, 97, 16, 2365);
			set_style(span2, "color", "green");
			add_location(span2, file$1, 101, 32, 2603);
			attr(span3, "class", "actor_list__actor_status svelte-1wx09m9");
			add_location(span3, file$1, 100, 16, 2531);
			attr(div, "class", "actor_list__actor_details svelte-1wx09m9");
			add_location(div, file$1, 96, 12, 2309);
			attr(li, "class", "actor_list__item svelte-1wx09m9");
			add_location(li, file$1, 91, 8, 2145);
		},

		m: function mount(target, anchor) {
			insert(target, li, anchor);
			append(li, span0);
			append(span0, t0);
			append(li, t1);
			append(li, hr);
			append(li, t2);
			append(li, div);
			append(div, span1);
			append(span1, t3);
			append(span1, t4);
			append(span1, t5);
			append(span1, t6);
			append(div, t7);
			append(div, span3);
			append(span3, t8);
			append(span3, span2);
			append(span2, t9);
			append(li, t10);
		},

		p: function update(changed, ctx) {
			if ((changed.$actors) && t0_value !== (t0_value = ctx.actor)) {
				set_data(t0, t0_value);
			}

			if ((changed.$map || changed.$actors) && t4_value !== (t4_value = ctx.$map.get(ctx.actor)['x'])) {
				set_data(t4, t4_value);
			}

			if ((changed.$map || changed.$actors) && t6_value !== (t6_value = ctx.$map.get(ctx.actor)['y'])) {
				set_data(t6, t6_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

function create_fragment$1(ctx) {
	var div, ul;

	function select_block_type(ctx) {
		if (ctx.$actors.length == 0) return create_if_block;
		return create_else_block;
	}

	var current_block_type = select_block_type(ctx);
	var if_block = current_block_type(ctx);

	return {
		c: function create() {
			div = element("div");
			ul = element("ul");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true }, false);
			var div_nodes = children(div);

			ul = claim_element(div_nodes, "UL", { id: true, class: true }, false);
			var ul_nodes = children(ul);

			if_block.l(ul_nodes);
			ul_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(ul, "id", "actor_list");
			attr(ul, "class", "svelte-1wx09m9");
			add_location(ul, file$1, 87, 4, 2006);
			attr(div, "id", "actor_status");
			attr(div, "class", "svelte-1wx09m9");
			add_location(div, file$1, 86, 0, 1978);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			append(div, ul);
			if_block.m(ul, null);
		},

		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(ul, null);
				}
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			if_block.d();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $actors, $map;

	validate_store(actors, 'actors');
	subscribe($$self, actors, $$value => { $actors = $$value; $$invalidate('$actors', $actors); });
	validate_store(map, 'map');
	subscribe($$self, map, $$value => { $map = $$value; $$invalidate('$map', $map); });

	return { $actors, $map };
}

class ActorStatus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
	}
}

/* src/routes/iot.svelte generated by Svelte v3.6.7 */

const file$2 = "src/routes/iot.svelte";

// (148:0) {:else}
function create_else_block$1(ctx) {
	var div0, div0_intro, div0_outro, t, div1, div1_intro, div1_outro, current;

	var map = new Map$1({ $$inline: true });

	var actorstatus = new ActorStatus({ $$inline: true });

	return {
		c: function create() {
			div0 = element("div");
			map.$$.fragment.c();
			t = space();
			div1 = element("div");
			actorstatus.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { id: true, class: true }, false);
			var div0_nodes = children(div0);

			map.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach);
			t = claim_text(nodes, "\n");

			div1 = claim_element(nodes, "DIV", { id: true }, false);
			var div1_nodes = children(div1);

			actorstatus.$$.fragment.l(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "id", "map");
			attr(div0, "class", "svelte-1hnwgxu");
			add_location(div0, file$2, 148, 0, 3722);
			attr(div1, "id", "actor_status");
			add_location(div1, file$2, 151, 0, 3811);
		},

		m: function mount(target, anchor) {
			insert(target, div0, anchor);
			mount_component(map, div0, null);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			mount_component(actorstatus, div1, null);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(map.$$.fragment, local);

			add_render_callback(() => {
				if (div0_outro) div0_outro.end(1);
				if (!div0_intro) div0_intro = create_in_transition(div0, fade, {duration: 200});
				div0_intro.start();
			});

			transition_in(actorstatus.$$.fragment, local);

			add_render_callback(() => {
				if (div1_outro) div1_outro.end(1);
				if (!div1_intro) div1_intro = create_in_transition(div1, fade, {duration: 200});
				div1_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			transition_out(map.$$.fragment, local);
			if (div0_intro) div0_intro.invalidate();

			div0_outro = create_out_transition(div0, fade, {duration: 0});

			transition_out(actorstatus.$$.fragment, local);
			if (div1_intro) div1_intro.invalidate();

			div1_outro = create_out_transition(div1, fade, {duration: 0});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div0);
			}

			destroy_component(map, );

			if (detaching) {
				if (div0_outro) div0_outro.end();
				detach(t);
				detach(div1);
			}

			destroy_component(actorstatus, );

			if (detaching) {
				if (div1_outro) div1_outro.end();
			}
		}
	};
}

// (143:8) {#if !arch_collapsed}
function create_if_block$1(ctx) {
	var div, img, div_intro, div_outro, current;

	return {
		c: function create() {
			div = element("div");
			img = element("img");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true }, false);
			var div_nodes = children(div);

			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(img, "src", src);
			attr(img, "alt", "architecture diagram");
			attr(img, "class", "svelte-1hnwgxu");
			add_location(img, file$2, 145, 4, 3668);
			attr(div, "id", "architecture__diagram");
			attr(div, "class", "svelte-1hnwgxu");
			add_location(div, file$2, 144, 0, 3576);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fade, {duration: 200});
				div_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			if (div_intro) div_intro.invalidate();

			div_outro = create_out_transition(div, fade, {duration: 0});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
				if (div_outro) div_outro.end();
			}
		}
	};
}

function create_fragment$2(ctx) {
	var div, h1, t0, t1, span, button, t2_value = ctx.arch_collapsed ? "+" : "-", t2, button_intro, button_outro, t3, current_block_type_index, if_block, if_block_anchor, current, dispose;

	var if_block_creators = [
		create_if_block$1,
		create_else_block$1
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (!ctx.arch_collapsed) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text("Factory Status");
			t1 = space();
			span = element("span");
			button = element("button");
			t2 = text(t2_value);
			t3 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			h1 = claim_element(div_nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t0 = claim_text(h1_nodes, "Factory Status");
			h1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			t1 = claim_text(nodes, "\n");

			span = claim_element(nodes, "SPAN", { style: true }, false);
			var span_nodes = children(span);

			button = claim_element(span_nodes, "BUTTON", { id: true, class: true }, false);
			var button_nodes = children(button);

			t2 = claim_text(button_nodes, t2_value);
			button_nodes.forEach(detach);
			span_nodes.forEach(detach);
			t3 = claim_text(nodes, " ");
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr(h1, "class", "svelte-1hnwgxu");
			add_location(h1, file$2, 136, 4, 3263);
			attr(div, "class", "header svelte-1hnwgxu");
			add_location(div, file$2, 135, 0, 3238);
			attr(button, "id", "architecture__collapse__button");
			attr(button, "class", "svelte-1hnwgxu");
			add_location(button, file$2, 139, 0, 3361);
			set_style(span, "position", "relative");
			set_style(span, "grid-row", "2");
			set_style(span, "grid-column", "1 /2");
			add_location(span, file$2, 138, 0, 3294);
			dispose = listen(button, "click", ctx.handle_collapse_click);
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			append(div, h1);
			append(h1, t0);
			insert(target, t1, anchor);
			insert(target, span, anchor);
			append(span, button);
			append(button, t2);
			insert(target, t3, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.arch_collapsed) && t2_value !== (t2_value = ctx.arch_collapsed ? "+" : "-")) {
				set_data(t2, t2_value);
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (button_outro) button_outro.end(1);
				if (!button_intro) button_intro = create_in_transition(button, fade, {duration: 200});
				button_intro.start();
			});

			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			if (button_intro) button_intro.invalidate();

			button_outro = create_out_transition(button, fade, {duration: 0});

			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
				detach(t1);
				detach(span);
				if (button_outro) button_outro.end();
				detach(t3);
			}

			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}

			dispose();
		}
	};
}

let src = '2019_07_19-arch-diagram.svg';

function instance$2($$self, $$props, $$invalidate) {
	
    let arch_collapsed = false;

    function handle_collapse_click(e) {
        $$invalidate('arch_collapsed', arch_collapsed = !arch_collapsed);
    }

	return { arch_collapsed, handle_collapse_click };
}

class Iot extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, []);
	}
}

export default Iot;
